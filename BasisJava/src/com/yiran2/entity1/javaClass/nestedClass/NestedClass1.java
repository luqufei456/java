package com.yiran2.entity1.javaClass.nestedClass;

/**
 * 成员内部类
 *
 * 外部类
 *
 * 1 内部类对象的创建依赖于外部类对象；
 * 2 内部类对象持有指向外部类对象的引用。
 *
 * 外部类的属性对于内部类都是可见的，可以直接访问
 *
 * 关于内部类如何访问外部类的成员， 分析之后其实也很简单， 主要是通过以下几步做到的：
 *      1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同，
 * 这个成员变量就是指向外部类对象的引用；
 *
 *      2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型，
 * 在构造方法内部使用这个参数为1中添加的成员变量赋值；
 *
 *      3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。
 *
 * 为什么内部类中不能有static属性或方法
 *      静态变量是要占用内存的，在编译时只要是定义为静态变量了，系统就会自动分配内存给他，
 *      而内部类是在宿主类编译完编译的，也就是说，必须有宿主类存在后才能有内部类，
 *      这也就和编译时就为静态变量分配内存产生了冲突，因为系统执行：运行宿主类->静态变量内存分配->内部类，
 *      而此时内部类的静态变量先于内部类生成，这显然是不可能的，所以不能定义静态变量！
 *
 * 为什么不能使用this.属性名访问外部类的属性，因为this代表的是内部类的实例，内部类本身是没有该属性的，
 * 存在的是外部类的引用。
 * */

public class NestedClass1 {
    private String name = "yiran";

    // 成员内部类
    public class InnerClass {

        public void innerMethod(){
            System.out.println("内部类的方法被调用了");
            // 内部类不能使用this.name 因为内部类名.属性名无法访问外部内的属性
            // 更不能使用 外部类名.属性名 除非是静态的,不过那就与内部类能使用外部类属性的特性无关了
            System.out.println("外部类的成员变量name值为："+name);
        }

    }

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}
